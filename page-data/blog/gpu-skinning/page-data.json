{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/gpu-skinning",
    "result": {"data":{"post":{"slug":"/blog/gpu-skinning","title":"GPU Skinning+GPU instancing for rendering 1000+ characters","date":"10.10.2022","tags":[{"name":"Unity development","slug":"unity-development"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"GPU Skinning+GPU instancing for rendering 1000+ characters\",\n  \"date\": \"2022-10-10T00:00:00.000Z\",\n  \"slug\": \"/blog/gpu-skinning\",\n  \"tags\": [\"Unity development\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/CPUSkinning.png\",\n    \"width\": \"100%\",\n    \"alt\": \"CPU computing SkinnedMesh\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 1 CPU computing SkinnedMesh\\n  \\t\")), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/GPUSkinning.png\",\n    \"width\": \"100%\",\n    \"alt\": \"GPU computing SkinnedMesh\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 2 GPU computing SkinnedMesh\\n  \\t\")), mdx(\"p\", null, \"GPU Skinning is a GPU calculation technique to free the CPU from calculating animation using Skinmesh renderer.\"), mdx(\"p\", null, \"When developing scenes with tons of thousands of people, the most computational cost comes from \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mesh calculated by the weight of Bones\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the Draw Call for a large amounts of meshes.\")), mdx(\"p\", null, \"The main concept would be using vertex shader to play the animation and use GPU instancing lower the draw call.\"), mdx(\"h1\", null, \"1. Skeleton animation\"), mdx(\"p\", null, \"The concept of a skeleton animation is to store the bones transformation info per frame and the bone index and its weight that affects each vertex. When playing the animation, the CPU make this calculation and change the vertex position accordingly. So an animation normally contains:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Bone structures\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mesh info\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Skin info( bone index and weights)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Key frame data\")), mdx(\"p\", null, \"the world position of vertex is defined by bones\"), mdx(\"p\", null, \"mesh vertex(defined in mesh space)\\u2014\\u2014>Bone space\\u2014\\u2014>world\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/SkeletionAnimation.png\",\n    \"width\": \"100%\",\n    \"alt\": \"How skeleton-based animation store data\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 3 How skeleton-based animation store data\\n  \\t\")), mdx(\"p\", null, \"if we can use vertex shader to replace the SkinnedMeshRenderer, then we can move the calculation to the GPU side which helps lower the CPU consumption. The technique is very similar to some other common shaders that we normally use, for example: flag, fish or grass.\"), mdx(\"undefined\", null, mdx(\"figure\", {\n    \"className\": \"third\"\n  }, \"\\n    \", mdx(\"img\", {\n    parentName: \"figure\",\n    \"style\": {\n      \"margin\": \"10px\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/Flag.jpg\",\n    \"width\": \"43%\"\n  }), \"\\n    \", mdx(\"img\", {\n    parentName: \"figure\",\n    \"style\": {\n      \"margin\": \"10px\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/Fish.gif\",\n    \"width\": \"50%\"\n  })), \"\\nBut we still need some important information to make the character move:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Bone Index and Bone Weight of each vertex\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Transformation data of bones per frame.\")), mdx(\"h1\", null, \"2.Get bone transformation data to texture\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/TransformationMatrix.png\",\n    \"width\": \"100%\",\n    \"alt\": \"Transformation matrix\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n  \\t\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"//locate to the frame\\nclip.SampleAnimation(gameObject, i / clip.frameRate);\\n\\n//get the bone transformation matrix\\nMatrix4x4 matrix = skinnedMeshRenderer.transform.worldToLocalMatrix * bones[j].localToWorldMatrix *bindPoses[j];\\n\\n\")), mdx(\"p\", null, \"after getting the bone transformation offset matrix, we can save the matrix , we can save the matrix info of each float to RGBA and finally convert to Texture2D. This way, the float can maintain precision. The process is described in the following picture.\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/BoneTransformation.jpg\",\n    \"width\": \"100%\",\n    \"alt\": \"Bone transformation info to Texture2D\\n\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 4 Bone transformation info to Texture2D\\n  \\t\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"// Convert the twelve float to RGBA to save precision accuracy.\\nfor (var j = 0; j < bonesCount; j++)\\n   {\\n          var matrix = transform.worldToLocalMatrix * bones[j].localToWorldMatrix * bindPoses[j];\\n\\n          colors[(i * bonesCount + j) * 12 + 0] = EncodeFloatRGBA(matrix.m00);\\n          colors[(i * bonesCount + j) * 12 + 1] = EncodeFloatRGBA(matrix.m01);\\n          colors[(i * bonesCount + j) * 12 + 2] = EncodeFloatRGBA(matrix.m02);\\n          colors[(i * bonesCount + j) * 12 + 3] = EncodeFloatRGBA(matrix.m03);\\n\\n         colors[(i * bonesCount + j) * 12 + 4] = EncodeFloatRGBA(matrix.m10);\\n         colors[(i * bonesCount + j) * 12 + 5] = EncodeFloatRGBA(matrix.m11);\\n         colors[(i * bonesCount + j) * 12 + 6] = EncodeFloatRGBA(matrix.m12);\\n         colors[(i * bonesCount + j) * 12 + 7] = EncodeFloatRGBA(matrix.m13);\\n\\n         colors[(i * bonesCount + j) * 12 + 8] = EncodeFloatRGBA(matrix.m20);\\n         colors[(i * bonesCount + j) * 12 + 9] = EncodeFloatRGBA(matrix.m21);\\n         colors[(i * bonesCount + j) * 12 + 10] = EncodeFloatRGBA(matrix.m22);\\n         colors[(i * bonesCount + j) * 12 + 11] = EncodeFloatRGBA(matrix.m23);\\n     }\\n\")), mdx(\"h1\", null, \"3.Mapping BoneIndex And Weight To MeshUV\"), mdx(\"p\", null, \"Although we have transformation information for each bone per frame, there is one more thing, that is, which bones are influencing a vertex and its weight. But if you think about it carefully, you can understand that this index and weight are static data of a Mesh.\"), mdx(\"p\", null, \"Since the Mesh is static, it is written directly into the Mesh. The most common one is of course the UV channel. UV is a Vector2 vector, so only one pair of weight index data can be stored at a time. If you have higher requirements for accuracy, you can use 2 UV channels or 4 UV channels.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"//Deep copy from original Mesh\\nvar bakedMesh = new Mesh();\\nbakedMesh = Instantiate(mesh);\\n\\n//Bake the index and weight info into Mesh UV2 and UV3\\nMappingBoneIndexAndWeightToMeshUV(bakedMesh, UVChannel.UV2, UVChannel.UV3);\\n\\n\")), mdx(\"h1\", null, \"4.Retrive info from Texture\"), mdx(\"p\", null, \"After getting the data, its time to replace the Skinedrenderer with Shader.\"), mdx(\"p\", null, \"BoneMartix material baked before pixel-by-pixel decoding in Shader, the current vertex is affected by those two bones(might be up to four bones based on the previous step), extract and assemble their matrix information:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"//find bone0 from BoneMatrix2Texture2D\\nfloat total = (y * _BoneCount + (int)(index.x)) * 12;\\nfloat4 line0 = readInBoneTex(total);\\nfloat4 line1 = readInBoneTex(total + 4);\\nfloat4 line2 = readInBoneTex(total + 8);\\n\\n//get bone0 Matrix4X4 transformation matrix\\nfloat4x4 mat1 = float4x4(line0, line1, line2, float4(0, 0, 0, 1));\\n\\n//find bone1 from BoneMatrix2Texture2D\\ntotal = (y * _BoneCount + (int)(index.y)) * 12;\\nline0 = readInBoneTex(total);\\nline1 = readInBoneTex(total + 4);\\nline2 = readInBoneTex(total + 8);\\n\\n//get bone1 Matrix4X4 transformation matrix\\nfloat4x4 mat2 = float4x4(line0, line1, line2, float4(0, 0, 0, 1));\\n\\n\")), mdx(\"p\", null, \"\\uFF08Vertex Shader\\uFF09\\uFF1A\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// get boneindex and weight\\nfloat2 index = v.iuv;\\nfloat2 weight = v.wuv;\\n\\n//make the vertex move\\nfloat4 pos = mul(mat1, v.vertex) * weight.x + mul(mat2, v.vertex) * (1 - weight.x);\\n\\n\")), mdx(\"h1\", null, \"5. GPU Instancing\"), mdx(\"p\", null, \"With the GPU Skinning technology, the skinning work in the CPU is transferred to the GPU for execution, and the running efficiency of the Unity scene is greatly improved. We can further optimize by introducing GPU Instancing technology.\"), mdx(\"p\", null, \"Now, each rendering of a character requires the CPU to communicate with the GPU. The CPU will tell the GPU the Mesh, Material and position information of the character, and the GPU is responsible for rendering according to the instructions. However, the problem is obvious: because we are rendering many identical characters, each time the CPU tells the GPU much of the same information (Mesh & Material), only the position information is different. Can the CPU tell the GPU all the positions that should be rendered at one time, avoiding a lot of invalid communication? GPU Instancing should be a good fit for this senario.\"), mdx(\"p\", null, \"GPU instancing is a\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.unity.cn/cn/current/Manual/optimizing-draw-calls.html\"\n  }, \"draw call optimization\"), \"\\xA0method that renders multiple copies of a mesh with the same material in a single draw call. Each copy of the mesh is called an instance. This is useful for drawing things that appear multiple times in a scene, for example, trees or bushes.\"), mdx(\"p\", null, \"GPU instancing renders identical meshes in the same draw call. To add variation and reduce the appearance of repetition, each instance can have different properties, such as\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Color\"), \"\\xA0or\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scale\"), \". Draw calls that render multiple instances appear in the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.unity.cn/cn/current/Manual/FrameDebugger.html\"\n  }, \"Frame Debugger\"), \"\\xA0as\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Draw Mesh (instanced)\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Send data to the GPU at one time, and use a drawing function to let the rendering pipeline draw multiple identical objects using this data\")), mdx(\"p\", null, \"With the GPU Skinning technology, the skinning work in the CPU is transferred to the GPU for execution, and the running efficiency of the Unity scene is greatly improved. We can further optimize by introducing GPU Instancing technology.\"), mdx(\"p\", null, \"Now, each rendering of a character requires the CPU to communicate with the GPU. The CPU will tell the GPU the Mesh, Material and position information of the character, and the GPU is responsible for rendering according to the instructions. However, the problem is obvious: because we are rendering many identical characters, each time the CPU tells the GPU much of the same information (Mesh & Material), only the position information is different. Can the CPU tell the GPU all the positions that should be rendered at one time, avoiding a lot of invalid communication? GPU Instancing came into being. \"), mdx(\"p\", null, \"By add the keyword in shader can enable the Auto GPU instancing\\uFF1A\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"#pragma multi_compile_instancing\\n\\n\")), mdx(\"p\", null, \"And we can also change Properties in the shader (for example time offset)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Properties\\n{\\n  //property needs to be changed\\n  _Offset(\\\"Offset\\\", Range(0, 1)) = 0\\n}\\n\\n\\xB7\\xB7\\xB7\\n//Declare\\nUNITY_INSTANCING_BUFFER_START(Props)\\n  UNITY_DEFINE_INSTANCED_PROP(float, _Offset)\\nUNITY_INSTANCING_BUFFER_END(Props)\\n\\xB7\\xB7\\xB7\\n\\n//use the property\\nfloat y = _Time.y * _FrameRate + UNITY_ACCESS_INSTANCED_PROP(Props, _Offset) * _FrameCount;\\n\\n\")), mdx(\"p\", null, \"After this, by click the Enable GPU Instancing, the GPU instancing is enabled\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/result.png\",\n    \"width\": \"100%\",\n    \"alt\": \"GPUSkinning, CPUSkinning\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 5 Left: GPUSkinning, Right: CPUSkinning\\n  \\t\")), mdx(\"p\", null, \"You can find a full version of example \", mdx(\"a\", {\n    href: \"https://github.com/Big-Bro222/UsefulUnityLibrary/tree/GPUSkinning\",\n    target: \"_blank\"\n  }, mdx(\"text\", {\n    className: \"link\"\n  }, \"here\"))), mdx(\"h1\", null, \"6. Conclusion\"), mdx(\"p\", null, \"By using GPU skinning and GPU instancing techniques, we can dramatically increase the number of characters can be presented inside a scene. However, because it\\u2019s based on vertex shader, we have to bake animation textures for each single one of them. And also, blending between different animations is hard to implement, which makes it hard to apply to precise animations. When dealing with detail character interactions, it\\u2019s always better to use a \\u201Cnormal\\u201D animator. \"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/gpu-skinning/PeopleStream.png\",\n    \"width\": \"50%\",\n    \"alt\": \"Rendering about one thousand people to simulate crowd stream\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n     Figure 6 Rendering about one thousand people to simulate crowd stream\\n  \\t\")), mdx(\"h1\", null, \"Reference\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zentia.github.io/2018/03/23/Engine/Unity/Unity-Skinned-Mesh/\"\n  }, \"https://zentia.github.io/2018/03/23/Engine/Unity/Unity-Skinned-Mesh/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/weixin_30784501/article/details/98346439?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-98346439-blog-100771084.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-98346439-blog-100771084.pc_relevant_default&utm_relevant_index=1\"\n  }, \"https://blog.csdn.net/weixin_30784501/article/details/98346439?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-98346439-blog-100771084.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-98346439-blog-100771084.pc_relevant_default&utm_relevant_index=1\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zhuanlan.zhihu.com/p/76562300\"\n  }, \"https://zhuanlan.zhihu.com/p/76562300\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/candycat1992/article/details/42127811\"\n  }, \"https://blog.csdn.net/candycat1992/article/details/42127811\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zhuanlan.zhihu.com/p/523702434\"\n  }, \"https://zhuanlan.zhihu.com/p/523702434\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://zhuanlan.zhihu.com/p/50640269\"\n  }, \"https://zhuanlan.zhihu.com/p/50640269\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Minghou-Lei/GPU-Skinning-Demo\"\n  }, \"https://github.com/Minghou-Lei/GPU-Skinning-Demo\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/chengkehan/GPUSkinning\"\n  }, \"https://github.com/chengkehan/GPUSkinning\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Unity-Technologies/Animation-Instancing\"\n  }, \"https://github.com/Unity-Technologies/Animation-Instancing\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"GPU Skinning is a GPU calculation technique to free the CPU from calculating animation using Skinmesh renderer. When developing scenes with…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/blog/gpu-skinning","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}