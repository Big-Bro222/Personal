{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/toon-shader",
    "result": {"data":{"post":{"slug":"/blog/toon-shader","title":"Toon Shaders","date":"03.02.2023","tags":[{"name":"Unity developments","slug":"unity-developments"},{"name":"Shader Effects","slug":"shader-effects"},{"name":"Graphics","slug":"graphics"}],"description":"thing learnt when implementing toon Shaders","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Toon Shaders\",\n  \"description\": \"thing learnt when implementing toon Shaders\",\n  \"date\": \"2023-02-03T00:00:00.000Z\",\n  \"slug\": \"/blog/toon-shader\",\n  \"tags\": [\"Unity developments\", \"Shader Effects\", \"Graphics\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Toon shading\"), \"\\xA0(often called\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cel shading\"), \") is a rendering style designed to make 3D surfaces emulate 2D, flat surfaces. This is a kind of NPR(Non-Photorealistic Rendering).The core concept of this shading technique is to have sharp diffuse edge and sharp specular reflections and also an Outline.\"), mdx(\"h1\", null, \"1. How to write a simple toon shader with unlit shader\"), mdx(\"h2\", null, \"1.1 Diffuse\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"//Diffuse light steps\\n float difLight=dot(worldLightDir,i.worldNormal)*0.5+0.5;\\n difLight = smoothstep(0,1,difLight);\\n float toon=floor(difLight*_Steps)/_Steps;\\n difLight=lerp(difLight,toon,_ToonEffect);\\n fixed3 diffuse=_LightColor0.rgb*albedo*_DiffuseColor.rgb*difLight;\\n\")), mdx(\"h2\", null, \"1.2 Specular\"), mdx(\"p\", null, \"The specular calculation of Blinn-Phong light model is to to use the dot product of vertex normal and the middle angle of lightdir and viewdir (halfdir)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"//halfDir is the middle angle of lightdir and viewdir\\n//_Gloss is a factor to controll specular strength\\nfloat spec=pow(max(0,dot(normal,halfDir)),_Gloss)\\n\\n\")), mdx(\"p\", null, \"But for toon shading, we skip the Gloss power and compare the dot product with a threshold using the step function. If the dot product is greater than the threshold the specular is 1, otherwise is 0\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"float spec=dot(normal,halfDir);\\nspec = step(threshold,spec);\\n\")), mdx(\"h2\", null, \"1.3 Rim\"), mdx(\"p\", null, \"Rim is related to the angle of view dir and vertex normal dir. \"), mdx(\"p\", null, \"Rim lighting is the addition of illumination to the edges of an object to simulate reflected light or backlighting. It is especially useful for toon shaders to help the object's\\xA0silhouette\\xA0stand out among the flat shaded surfaces.\"), mdx(\"p\", null, \"The \\\"rim\\\" of an object will be defined as surfaces that are facing\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"away\"), \"\\xA0from the camera. We will therefore calculate the rim by taking the dot product of the normal and the view direction, and\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inverting\"), \"\\xA0it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"float rimIntensity = smoothstep(_RimAmount - 0.01, _RimAmount + 0.01, rimDot);\\nfloat4 rim = rimIntensity * _RimColor;\\n\")), mdx(\"h2\", null, \"1.4 Outline\"), mdx(\"p\", null, \"To render an outline, here we are using a simple method: to add an additional pass and add an outline offset and then draw the normal object on the top of this pass\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"//1.object normal extrusion\\nv.vertex.xyz+=_Outline*v.normal;\\no.vertex = UnityObjectToClipPos(v.vertex);\\n\\n//2.view space normal extrusion\\nfloat4 pos = mul(UNITY_MATRIX_V, mul(unity_ObjectToWorld, v.vertex));\\nfloat3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV,v.normal));\\npos = pos + float4(normal,0) * _Outline;\\no.vertex =  mul(UNITY_MATRIX_P, pos);\\n\\n//3.clip space normal extrusion\\no.vertex = UnityObjectToClipPos(v.vertex);\\nfloat3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\\nfloat2 viewNormal = TransformViewToProjection(normal.xy);\\no.vertex.xy += viewNormal * _Outline;\\n\")), mdx(\"br\", null), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/toon-shader/ToonShader.png\",\n    \"width\": \"50%\",\n    \"alt\": \"Assets\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 1 Simple toon shader\\n  \\t\")), mdx(\"p\", null, \"here is a full version of the toon shader based on vertex and fragment shader\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"Shader \\\"Toon/ToonShader\\\"\\n{\\n    Properties\\n    {\\n        _MainTex (\\\"Texture\\\", 2D) = \\\"white\\\" {}\\n        _DiffuseColor(\\\"Diffuse\\\",Color)=(1,1,1,1)\\n        _Outline(\\\"Outline Width\\\",Range(0,1))=1\\n        _OutlineColor(\\\"Outline Color\\\",Color)=(0,0,0,1)\\n        _Steps(\\\"Steps\\\",Range(1,30)) = 1\\n        _ToonEffect(\\\"ToonEffect\\\", Range(0,1)) = 0.5\\n        _Specular(\\\"Specular Color\\\",Color)=(1,1,1,1)\\n        _SpecularScale(\\\"Specular Scale\\\",Range(0.0001,3))=1\\n        _RimColor(\\\"Rim Light Color\\\",Color)=(1,1,1,1)\\n        _RimPower(\\\"Rim Strength\\\", Range(0.00000001,3))=1\\n        _XRayColor(\\\"Oculusion Color\\\",Color)=(1,1,1,1)\\n        _XRayPower(\\\"XRay Power\\\",Range(0.0001,3))=1\\n    }\\n    SubShader\\n    {\\n        Tags\\n        {\\n            \\\"Queue\\\"= \\\"Geometry+1000\\\" \\\"RenderType\\\"=\\\"Opaque\\\"\\n        }\\n        LOD 100\\n        Pass\\n        {\\n            Name \\\"Outline\\\"\\n            Cull Front\\n\\n            CGPROGRAM\\n            #pragma vertex vert\\n            #pragma fragment frag\\n\\n            #include \\\"UnityCG.cginc\\\"\\n            #include \\\"Lighting.cginc\\\"\\n\\n            struct appdata\\n            {\\n                float4 vertex : POSITION;\\n                float2 uv : TEXCOORD0;\\n            };\\n\\n            struct v2f\\n            {\\n                float4 vertex : SV_POSITION;\\n            };\\n\\n            float _Outline;\\n            fixed4 _OutlineColor;\\n            float _Steps;\\n            float _ToolEffect;\\n\\n            v2f vert(appdata_base v)\\n            {\\n                v2f o;\\n                //\\u7269\\u4F53\\u6CD5\\u7EBF\\u5916\\u6269\\n                //v.vertex.xyz+=_Outline*v.normal;\\n                //o.vertex = UnityObjectToClipPos(v.vertex);\\n\\n                //\\u89C6\\u89D2\\u7A7A\\u95F4\\u6CD5\\u7EBF\\u5916\\u62D3\\n                //float4 pos = mul(UNITY_MATRIX_V, mul(unity_ObjectToWorld, v.vertex));\\n                //float3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV,v.normal));\\n                //pos = pos + float4(normal,0) * _Outline;\\n                //o.vertex =  mul(UNITY_MATRIX_P, pos);\\n\\n                //\\u88C1\\u526A\\u7A7A\\u95F4\\u6CD5\\u7EBF\\u5916\\u62D3\\n                o.vertex = UnityObjectToClipPos(v.vertex);\\n                float3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\\n                float2 viewNormal = TransformViewToProjection(normal.xy);\\n                o.vertex.xy += viewNormal * _Outline;\\n                return o;\\n            }\\n\\n            fixed4 frag(v2f i) : SV_Target\\n            {\\n                return _OutlineColor;\\n            }\\n            ENDCG\\n        }\\n\\n        Pass\\n        {\\n            CGPROGRAM\\n            #pragma vertex vert\\n            #pragma fragment frag\\n\\n            #include \\\"UnityCG.cginc\\\"\\n            #include \\\"Lighting.cginc\\\"\\n\\n            struct v2f\\n            {\\n                float4 pos : SV_POSITION;\\n                float2 uv : TEXCOORD0;\\n                fixed3 worldNormal:TEXCOORD1;\\n                fixed3 worldPos:TEXCOORD2;\\n            };\\n\\n            sampler2D _MainTex;\\n            float4 _MainTex_ST;\\n            float4 _DiffuseColor;\\n            float _Steps;\\n            float _ToonEffect;\\n            fixed4 _RimColor;\\n            float _RimPower;\\n            float _SpecularScale;\\n            fixed4 _Specular;\\n\\n            v2f vert(appdata_base v)\\n            {\\n                v2f o;\\n                o.pos = UnityObjectToClipPos(v.vertex);\\n                o.worldNormal = UnityObjectToWorldNormal(v.normal);\\n                o.worldPos = mul(unity_ObjectToWorld, o.pos);\\n                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\\n                return o;\\n            }\\n\\n            fixed4 frag(v2f i) : SV_Target\\n            {\\n                // sample the texture\\n                fixed4 albedo = tex2D(_MainTex, i.uv);\\n                fixed3 worldLightDir = UnityWorldSpaceLightDir(i.worldPos);\\n\\n                //view Direction\\n                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));\\n\\n                //Diffuse light steps\\n                float difLight = dot(worldLightDir, i.worldNormal) * 0.5 + 0.5;\\n                difLight = smoothstep(0, 1, difLight);\\n                float toon = floor(difLight * _Steps) / _Steps;\\n                difLight = lerp(difLight, toon, _ToonEffect);\\n                fixed3 diffuse = _LightColor0.rgb * _DiffuseColor.rgb * difLight;\\n\\n                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\\n\\n                fixed3 halfDir = normalize(worldLightDir + viewDir);\\n                float spec = dot(i.worldNormal, halfDir);\\n                fixed w = fwidth(spec) * 2.0;\\n                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(\\n                    0.0001, _SpecularScale);\\n\\n                /*float rim = 1 - dot(i.worldNormal, viewDir);\\n                fixed3 rimColor = _RimColor * pow(rim, 1 / _RimPower);*/\\n                float rimdot = 1 - dot(i.worldNormal, viewDir);\\n                float rimIntensity = smoothstep(_RimPower - 0.01, _RimPower + 0.01, rimdot);\\n                float4 rim = rimIntensity * _RimColor;\\n                return float4(ambient + diffuse + specular + rim, 1);\\n            }\\n            ENDCG\\n        }\\n        Pass\\n        {\\n            Tags\\n            {\\n                \\\"LightMode\\\"=\\\"ShadowCaster\\\"\\n            }\\n\\n            CGPROGRAM\\n            #pragma vertex vert\\n            #pragma fragment frag\\n            #pragma multi_compile_shadowcaster\\n            #include \\\"UnityCG.cginc\\\"\\n\\n            struct v2f\\n            {\\n                V2F_SHADOW_CASTER;\\n            };\\n\\n            v2f vert(appdata_base v)\\n            {\\n                v2f o;\\n                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\\n                return o;\\n            }\\n\\n            float4 frag(v2f i) : SV_Target\\n            {\\n                SHADOW_CASTER_FRAGMENT(i)\\n            }\\n            ENDCG\\n        }\\n\\n    }\\n}\\n\")), mdx(\"h1\", null, \"2. Toon effect in Surface shader\"), mdx(\"p\", null, \"we can also use Surface shader to implement the toon effect. The main difference is that we need to customize the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html\"\n  }, \"LightMode\"), \" in Surface shader to achieve this. And the base calculation are similar to the unlit shader. Surface shader enable easier and fast implementation of shadow casting and multiple lights handle\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"        //our lighting function. Will be called once per light\\n        float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, float shadowAttenuation){\\n            //how much does the normal point towards the light?\\n            float towardsLight = dot(s.Normal, lightDir);\\n            // make the lighting a hard cut\\n            float towardsLightChange = fwidth(towardsLight);\\n            float lightIntensity = smoothstep(0, towardsLightChange, towardsLight);\\n\\n        #ifdef USING_DIRECTIONAL_LIGHT\\n            //for directional lights, get a hard vut in the middle of the shadow attenuation\\n            float attenuationChange = fwidth(shadowAttenuation) * 0.5;\\n            float shadow = smoothstep(0.5 - attenuationChange, 0.5 + attenuationChange, shadowAttenuation);\\n        #else\\n            //for other light types (point, spot), put the cutoff near black, so the falloff doesn't affect the range\\n            float attenuationChange = fwidth(shadowAttenuation);\\n            float shadow = smoothstep(0, attenuationChange, shadowAttenuation);\\n        #endif\\n            lightIntensity = lightIntensity * shadow;\\n\\n            //calculate shadow color and mix light and shadow based on the light. Then taint it based on the light color\\n            float3 shadowColor = s.Albedo * _ShadowTint;\\n            float4 color;\\n            color.rgb = lerp(shadowColor, s.Albedo, lightIntensity) * _LightColor0.rgb;\\n            color.a = s.Alpha;\\n            return color;\\n        }\\n\")), mdx(\"undefined\", null, mdx(\"br\", null), mdx(\"br\", null), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/toon-shader/ToonShaderSurface.png\",\n    \"width\": \"50%\",\n    \"alt\": \"Assets\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 2 Surface toon shader\\n  \\t\"))), mdx(\"p\", null, \"Multiple lights and cast shadow\"), mdx(\"p\", null, \"The full shader script is as follow\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"Shader \\\"Toon/ToonShaderSurfaceBigBro\\\"\\n{\\n    Properties\\n    {\\n        _Color (\\\"Color\\\", Color) = (1,1,1,1)\\n        _MainTex (\\\"Albedo (RGB)\\\", 2D) = \\\"white\\\" {}\\n        _Outline(\\\"Outline Width\\\",Range(0,1))=1\\n        _OutlineColor(\\\"Outline Color\\\",Color)=(0,0,0,1)\\n        _Steps(\\\"Steps\\\",Range(1,30)) = 1\\n        _ToonEffect(\\\"ToonEffect\\\", Range(0,1)) = 0.5\\n        _DiffuseColor(\\\"Diffuse\\\",Color)=(1,1,1,1)\\n        _Specular(\\\"Specular Color\\\",Color)=(1,1,1,1)\\n        _SpecularScale(\\\"Specular Scale\\\",Range(0.0001,3))=1\\n    }\\n    SubShader\\n    {\\n        Tags\\n        {\\n            \\\"RenderType\\\"=\\\"Opaque\\\"\\n        }\\n        LOD 200\\n        Pass\\n        {\\n            Name \\\"Outline\\\"\\n            Cull Front\\n\\n            CGPROGRAM\\n            #pragma vertex vert\\n            #pragma fragment frag\\n\\n            #include \\\"UnityCG.cginc\\\"\\n            #include \\\"Lighting.cginc\\\"\\n\\n            struct appdata\\n            {\\n                float4 vertex : POSITION;\\n                float2 uv : TEXCOORD0;\\n            };\\n\\n            struct v2f\\n            {\\n                float4 vertex : SV_POSITION;\\n            };\\n\\n            float _Outline;\\n            fixed4 _OutlineColor;\\n\\n            v2f vert(appdata_base v)\\n            {\\n                v2f o;\\n                //\\u88C1\\u526A\\u7A7A\\u95F4\\u6CD5\\u7EBF\\u5916\\u62D3\\n                o.vertex = UnityObjectToClipPos(v.vertex);\\n                float3 normal = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\\n                float2 viewNormal = TransformViewToProjection(normal.xy);\\n                o.vertex.xy += viewNormal * _Outline;\\n                return o;\\n            }\\n\\n            fixed4 frag(v2f i) : SV_Target\\n            {\\n                return _OutlineColor;\\n            }\\n            ENDCG\\n        }\\n\\n        CGPROGRAM\\n        #pragma surface surf Toon addshadow\\n\\n        float4 _DiffuseColor;\\n        fixed4 _Color;\\n        float _Steps;\\n        float _ToonEffect;\\n        float _SpecularScale;\\n        fixed4 _Specular;\\n\\n        half4 LightingToon(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten)\\n        {\\n            //Diffuse light steps\\n            float difLight = dot(lightDir, s.Normal) * 0.5 + 0.5;\\n            difLight = smoothstep(0, 1, difLight);\\n            float toon = floor(difLight * _Steps) / _Steps;\\n            difLight = lerp(difLight, toon, _ToonEffect);\\n            fixed3 diff = _LightColor0.rgb * _DiffuseColor.rgb * difLight;\\n\\n            fixed3 halfDir = normalize(lightDir + viewDir);\\n            float spec = dot(s.Normal, halfDir);\\n            fixed w = fwidth(spec) * 2.0;\\n            fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(\\n                0.0001, _SpecularScale);\\n\\n            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * _Color;\\n\\n            //custom shadow\\n            #ifdef USING_DIRECTIONAL_LIGHT\\n            float attenuationChange = fwidth(atten) * 0.5;\\n            float shadow = smoothstep(0.5 - attenuationChange, 0.5 + attenuationChange, atten);\\n            #else\\n            float attenuationChange = fwidth(atten);\\n            float shadow = smoothstep(0, attenuationChange, atten);\\n            #endif\\n            half4 c;\\n            c.rgb = (ambient + diff + specular) * atten * s.Albedo;\\n            c.a = s.Alpha;\\n            return c;\\n        }\\n\\n        struct Input\\n        {\\n            float2 uv_MainTex;\\n        };\\n\\n        sampler2D _MainTex;\\n\\n        void surf(Input IN, inout SurfaceOutput o)\\n        {\\n            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;\\n        }\\n        ENDCG\\n    }\\n    FallBack \\\"Diffuse\\\"\\n}\\n\")), mdx(\"h1\", null, \"3. Other effects in Toon shader\"), mdx(\"h2\", null, \"3.1 Light turbulance\"), mdx(\"p\", null, \"To enable a light turbulance for a torch, the trick is to add as offset for the lightDir\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"float3 shakeOffset = float3(0, 0, 0);\\nshakeOffset.x = sin(_Time.z * 15);\\nshakeOffset.y = sin(_Time.z * 13 + 5);\\nshakeOffset.z = sin(_Time.z * 12 + 7);\\n\\n#ifdef POINT\\nlightDir += shakeOffset * 0.1f;\\n#endif\\n\")), mdx(\"undefined\", null, mdx(\"br\", null), mdx(\"br\", null), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/toon-shader/LightTurbulance.gif\",\n    \"width\": \"50%\",\n    \"alt\": \"Assets\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 3 LightTurbulance\\n  \\t\"))), mdx(\"h2\", null, \"3.2 Hair specular\"), mdx(\"p\", null, \"Kajiya-Kay Shading Model\"), mdx(\"h2\", null, \"3.3 With multiple lights\"), mdx(\"p\", null, \"There is another way to add multiple lights. By default, the Unity light system only supports four light sources. But we can add lights manually to make sure that every light has been calculate throw for shadow casting.\"), mdx(\"p\", null, \"First there should be a LitTag to mark which light we want to take count.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"public class MultiLitsTag:MonoBehaviour\\n{\\n    public float shakeStrength = 0.5f;\\n    public int litSorting = 0;\\n}\\n\")), mdx(\"p\", null, \"Then generate a multilights container, and send the following message to shader:\"), mdx(\"p\", null, \"(float4)_LitPosList: xyz is the world position, z can be another light perticular factor\"), mdx(\"p\", null, \"(float4)_LitColList:xyz is the light color, w is the light range\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"public class MultiLitsContainer : MonoBehaviour\\n{\\n    [SerializeField] private Transform[] pointLits;\\n\\n    private Light[] _pointLightList;\\n\\n    private MultiLitsTag[] _lightTagList;\\n    // Start is called before the first frame update\\n    void Awake()\\n    {\\n        _pointLightList = new Light[pointLits.Length];\\n        _lightTagList = new MultiLitsTag[pointLits.Length];\\n        for (int i = 0; i < pointLits.Length; i++)\\n        {\\n            _pointLightList[i] = pointLits[i].GetComponent<Light>();\\n            _lightTagList[i]=pointLits[i].GetComponent<MultiLitsTag>();\\n        }\\n    }\\n\\n    // Update is called once per frame\\n    void Update()\\n    {\\n        Vector4[] litPosList = new Vector4[10];\\n        Vector4[] litColList = new Vector4[10];\\n\\n        for (int i = 0; i < pointLits.Length; i++)\\n        {\\n            litPosList[i] = new Vector4(pointLits[i].position.x,pointLits[i].position.y,pointLits[i].position.z,_lightTagList[i].shakeStrength);\\n            litColList[i] = new Vector4(_pointLightList[i].color.r,_pointLightList[i].color.g,_pointLightList[i].color.b,_pointLightList[i].range);\\n        }\\n        Shader.SetGlobalFloat(\\\"_LitCount\\\",pointLits.Length);\\n        Shader.SetGlobalVectorArray(\\\"_LitPosList\\\",litPosList);\\n        Shader.SetGlobalVectorArray(\\\"_LitColList\\\",litColList);\\n    }\\n}\\n\")), mdx(\"p\", null, \" And the shader would be as following\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-glsl\"\n  }, \"Shader \\\"Toon/ToonMultipleLightShader\\\"\\n{\\n    Properties\\n    {\\n        _Tint(\\\"Tint\\\",Color)=(1,1,1,1)\\n        _MainTex (\\\"Texture\\\", 2D) = \\\"white\\\" {}\\n        _UnlitColor(\\\"Shadow Color\\\",Color)=(0.5,0.5,0.5,1)\\n        _MultiListFadeDistance(\\\"MultiList FadeDistance\\\",Float)=20\\n        \\n        _RimColor(\\\"Rim Color\\\",Color)=(0.5,0.5,0.5,1)\\n        _RimLightSampler (\\\"RimLight Sampler\\\", 2D) = \\\"white\\\" {}\\n        _RimIntensity(\\\"Rim Intensity\\\",Float)=10\\n        _UnlitThreshold(\\\"Shadow Range\\\",Range(0,1))=0.1\\n    }\\n    SubShader\\n    {\\n        Tags\\n        {\\n            \\\"Queue\\\"=\\\"Geometry\\\" \\\"RenderType\\\"=\\\"Opaque\\\"\\n        }\\n        LOD 100\\n\\n        Pass\\n        {\\n            Tags\\n            {\\n                \\\"LightMode\\\"=\\\"ForwardBase\\\"\\n            }\\n            CGPROGRAM\\n            #pragma vertex vert\\n            #pragma fragment frag\\n\\n            #include \\\"UnityCG.cginc\\\"\\n\\n            #pragma multi_compile_fwdbase\\n            #include \\\"AutoLight.cginc\\\"\\n            #include \\\"UnityLightingCommon.cginc\\\"\\n\\n            struct appdata\\n            {\\n                float4 vertex : POSITION;\\n                float3 normal : NORMAL;\\n                float2 uv : TEXCOORD0;\\n            };\\n\\n            struct v2f\\n            {\\n                float4 pos:SV_POSITION;\\n                float4 posWorld:TEXCOORD0;\\n                float3 normal:TEXCOORD1;\\n                float2 uv : TEXCOORD2;\\n                float3 camDir: TEXCOORD3;\\n                float3 lightDir: TEXCOORD4;\\n                LIGHTING_COORDS(5, 6)\\n            };\\n\\n            sampler2D _MainTex;\\n            float4 _MainTex_ST;\\n            fixed4 _Tint;\\n            fixed4 _UnlitColor;\\n            \\n            float _UnlitThreshold;\\n            float _MultiListFadeDistance;\\n\\n            fixed4 _RimColor;\\n            sampler2D _RimLightSampler;\\n            float _RimIntensity;\\n\\n            float _LitCount;\\n            float4 _LitPosList[10];\\n            float4 _LitColList[10];\\n\\n            v2f vert(appdata v)\\n            {\\n                v2f o;\\n                o.pos = UnityObjectToClipPos(v.vertex);\\n                o.posWorld = mul(unity_ObjectToWorld, v.vertex);\\n                o.normal = UnityObjectToWorldNormal(v.normal);\\n                o.camDir = normalize(_WorldSpaceCameraPos - o.posWorld);\\n                o.lightDir = WorldSpaceLightDir(v.vertex);\\n                o.uv = TRANSFORM_TEX(v.uv, _MainTex);\\n                return o;\\n            }\\n\\n            fixed4 frag(v2f i) : SV_Target\\n            {\\n                // sample the texture\\n                fixed4 col = tex2D(_MainTex, i.uv) * _Tint;\\n\\n                //add fire shake effect\\n                fixed4 pointLitCol = fixed4(0, 0, 0, 0);\\n                fixed pointLit = 0;\\n                float3 shakeOffset = float3(0, 0, 0);\\n                shakeOffset.x = sin(_Time.z * 15);\\n                shakeOffset.y = sin(_Time.z * 13+5);\\n                shakeOffset.z = sin(_Time.z * 12+7);\\n\\n                for (int n = 0; n < _LitCount; n++)\\n                {\\n                    float litDist = distance(_LitPosList[n].xyz, i.posWorld.xyz);\\n                    float viewDist = distance(_LitPosList[n].xyz, _WorldSpaceCameraPos);\\n                    float viewFade = 1 - saturate(viewDist / _MultiListFadeDistance);\\n                    if (litDist < _MultiListFadeDistance)\\n                    {\\n                        float3 litDir = _LitPosList[n].xyz - i.posWorld.xyz;\\n                        litDir += shakeOffset * 0.07 * _LitPosList[n].w;\\n                        litDir = normalize(litDir);\\n                        fixed newlitValue = max(0, dot(i.normal, litDir)) * (_LitPosList[n].w - litDist) * viewFade >\\n                            0.3;\\n                        fixed4 newlitCol = newlitValue * fixed4(_LitColList[n].xyz, 1);\\n                        pointLitCol = lerp(pointLitCol, newlitCol, newlitValue);\\n                    }\\n                }\\n                \\n                //light and shadow\\n                float3 normalDirection = normalize(i.normal);\\n                float attenuation = LIGHT_ATTENUATION(i);\\n                float3 lightDirection = normalize(_WorldSpaceLightPos0).xyz;\\n                fixed3 lightColor = _Tint.rgb * _UnlitColor.rgb * _LightColor0.rgb;\\n                if (attenuation * max(0.0, dot(normalDirection, lightDirection)) >= _UnlitThreshold)\\n                {\\n                    lightColor = _LightColor0.rgb * _Tint.rgb;\\n                }\\n\\n                //Rimlight\\n                float normalDotCam = dot(i.normal, i.camDir.xyz);\\n                float falloffU = clamp(1.0 - abs(normalDotCam), 0.02, 0.98);\\n\\n                float rimlightDot = saturate(0.5 * (dot(i.normal, i.lightDir + float3(-1, 0, 0)) + 1.5));\\n                falloffU = saturate(rimlightDot * falloffU);\\n                falloffU = tex2D(_RimLightSampler, float2(falloffU, 0.25f)).r;\\n                float3 rimCol = falloffU * col * _RimColor * _RimIntensity;\\n\\n                return float4(col.rgb * (lightColor.rgb + pointLitCol) + rimCol, 1.0);\\n            }\\n            ENDCG\\n        }\\n    }\\n    Fallback \\\"VertexLit\\\"\\n}\\n\")), mdx(\"undefined\", null, mdx(\"br\", null), mdx(\"br\", null), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/toon-shader/multilight.png\",\n    \"width\": \"50%\",\n    \"alt\": \"Assets\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 4 Multiple light toon shader\\n  \\t\"))), mdx(\"h1\", null, \"Reference\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://sorumi.xyz/posts/unity-toon-shader/\"\n  }, \"https://sorumi.xyz/posts/unity-toon-shader/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/QO_GQ/article/details/119616656\"\n  }, \"https://blog.csdn.net/QO_GQ/article/details/119616656\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/csuyuanxing/article/details/123519895\"\n  }, \"https://blog.csdn.net/csuyuanxing/article/details/123519895\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cnblogs.com/littleperilla/p/15759993.html\"\n  }, \"https://www.cnblogs.com/littleperilla/p/15759993.html\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://roystan.net/articles/toon-shader/\"\n  }, \"https://roystan.net/articles/toon-shader/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.ronja-tutorials.com/post/032-improved-toon/\"\n  }, \"https://www.ronja-tutorials.com/post/032-improved-toon/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://walkingfat.com/%E3%80%8A%E5%A1%9E%E5%B0%94%E8%BE%BE-%E8%8D%92%E9%87%8E%E4%B9%8B%E6%81%AF%E3%80%8B%E4%B8%AD%E8%A7%92%E8%89%B2%E5%8F%97%E5%A4%9A%E4%B8%AA%E7%82%B9%E5%85%89%E6%BA%90%E5%BD%B1%E5%93%8D%E5%81%9A%E6%B3%95/\"\n  }, \"http://walkingfat.com/\\u300A\\u585E\\u5C14\\u8FBE-\\u8352\\u91CE\\u4E4B\\u606F\\u300B\\u4E2D\\u89D2\\u8272\\u53D7\\u591A\\u4E2A\\u70B9\\u5149\\u6E90\\u5F71\\u54CD\\u505A\\u6CD5/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://tuyg.top/archives/876\"\n  }, \"http://tuyg.top/archives/876\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html\"\n  }, \"https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Toon shading  (often called  cel shading ) is a rendering style designed to make 3D surfaces emulate 2D, flat surfaces. This is a kind of…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/blog/toon-shader","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}