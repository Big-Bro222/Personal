{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/zenject/1",
    "result": {"data":{"post":{"slug":"/blog/zenject/1","title":"DI in Zenject 1 (Basic concepts and Hello world)","date":"03.07.2022","tags":[{"name":"Unity development","slug":"unity-development"},{"name":"Design Pattern","slug":"design-pattern"}],"description":"A discussion for C# System.Collections and System.Collection.generic","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DI in Zenject 1 (Basic concepts and Hello world)\",\n  \"description\": \"A discussion for C# System.Collections and System.Collection.generic\",\n  \"date\": \"2022-07-03T00:00:00.000Z\",\n  \"slug\": \"/blog/zenject/1\",\n  \"tags\": [\"Unity development\", \"Design Pattern\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"DI in Zenject (Basic concepts and Hello world)\"), mdx(\"h1\", null, \"1. Zenject Hello world\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject\"\n  }, \"Zenject\"), \" is a lightweight highly performant DI(dependency injection) framework built specifically to target Unity 3D. The traditional way of handling dependency can cause a lot of issues, like referring to a single dependency repeatedly, and easy cause errors while changing a dependency.\"), mdx(\"undefined\", null, mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/zenject-1/traditional_dependency.png\",\n    \"width\": \"100%\",\n    \"alt\": \"traditional_dependency.png\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 1 Traditional Way of Dependency Management\\n  \\t\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/zenject-1/dependency_injection_way.png\",\n    \"width\": \"100%\",\n    \"alt\": \"dependency_injection_way.png\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 2 Dependency Injected way of dependency management\\n  \\t\"))), mdx(\"p\", null, \"The workflow of Zenject(and most DI framework) are as follow:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Bind the dependency into the Zenject DiContainer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Inject the dependency into different code blocks\")), mdx(\"p\", null, \"Just that simple.\"), mdx(\"p\", null, \"To get Zenject work for the first time, you can follow the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject#hello-world-example\"\n  }, \"Hello world example\"), \" from the official documentation.\"), mdx(\"p\", null, \"If you are new to this topic, you should pause here and go to checkout the example and then come back.\"), mdx(\"h1\", null, \"2. Zenject Inject\"), mdx(\"p\", null, \"There are four types of Zenject injections:\"), mdx(\"p\", null, \"1 -\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Constructor Injection\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Foo\\n{\\n    IBar _bar;\\n\\n    public Foo(IBar bar)\\n    {\\n        _bar = bar;\\n    }\\n}\\n\")), mdx(\"p\", null, \"2 -\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Field Injection\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Foo\\n{\\n    [Inject]\\n    IBar _bar;\\n}\\n\")), mdx(\"p\", null, \"Field injection occurs immediately after the constructor is called. All fields that are marked with the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Inject]\"), \"\\xA0attribute are looked up in the container and given a value. Note that these fields can be private or public and injection will still occur.\"), mdx(\"p\", null, \"3 -\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Property Injection\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Foo\\n{\\n    [Inject]\\n    public IBar Bar\\n    {\\n        get;\\n        private set;\\n    }\\n}\\n\")), mdx(\"p\", null, \"4 -\\xA0\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Method Injection\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Foo\\n{\\n    IBar _bar;\\n    Qux _qux;\\n\\n    [Inject]\\n    public void Init(IBar bar, Qux qux)\\n    {\\n        _bar = bar;\\n        _qux = qux;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Inject methods are the recommended approach for MonoBehaviours , since MonoBehaviours cannot have constructors.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Note however that it is usually not a good idea to use inject methods for initialization logic. Often it is better to use IInitializable.Initialize or Start() methods instead, since this will allow the entire initial object graph to be created first.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The best practice is to prefer constructor/method injection compared to field/property injection.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For further information go to check \", mdx(\"em\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://github.com/modesttree/Zenject#injection\"\n  }, \"Introduction to Zenject API / Injection\")))), mdx(\"h1\", null, \"3. Zenject Bind\"), mdx(\"p\", null, \"Every dependency injection framework is ultimately just a framework to bind types to instances.\"), mdx(\"p\", null, \"In Zenject, dependency mapping is done by adding bindings to something called a container. The container should then 'know' how to create all the object instances in your application, by recursively resolving all dependencies for a given object.\"), mdx(\"p\", null, \"Each Zenject application therefore must tell the container how to resolve each of these dependencies, which is done via Bind commands. For example, given the following class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Foo\\n{\\n    IBar _bar;\\n\\n    public Foo(IBar bar)\\n    {\\n        _bar = bar;\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can wire up the dependencies for this class with the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind<Foo>().AsSingle();\\nContainer.Bind<IBar>().To<Bar>().AsSingle();\\n\")), mdx(\"p\", null, \"A full type of binding options are as follow. Most of which have their default setup. More details can be found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject#binding\"\n  }, \"documentation\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind<ContractType>()\\n    .WithId(Identifier)\\n    .To<ResultType>()\\n    .From***ConstructionMethod***()\\n    .As***Scope***()\\n    .WithArguments(Arguments)\\n    .OnInstantiated(InstantiatedCallback)\\n    .When(Condition)\\n    .(Copy|Move)Into(All|Direct)SubContainers()\\n    .NonLazy()\\n    .IfNotBound();\\n\")), mdx(\"p\", null, \"tips\\uFF1A to get a better understanding the first time, you can use.GetHashCode to check out if the instances are the same\"), mdx(\"h2\", null, \"Other Bindings\"), mdx(\"p\", null, \"zenject binding\"), mdx(\"p\", null, \"Yet another way to do this is to use the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZenjectBinding\"), \"\\xA0component. You can do this by adding a\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZenjectBinding\"), \"\\xA0MonoBehaviour to the same game object that you want to be automatically added to the Zenject container.\"), mdx(\"p\", null, \"For example, if you have a MonoBehaviour of type\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \"\\xA0in your scene, you can just add\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZenjectBinding\"), \"\\xA0alongside it, and then drag the Foo component into the Component property of the ZenjectBinding component.\"), mdx(\"left\", null, \"\\n    \", mdx(\"img\", {\n    parentName: \"left\",\n    \"style\": {\n      \"borderRadius\": \"0.1125em\",\n      \"boxShadow\": \"0 2px 1px 0 rgba(34,36,38,.12),0 2px 5px 0 rgba(34,36,38,.08)\"\n    },\n    \"src\": \"https://cdn.jsdelivr.net/gh/Big-Bro222/StaticFileServer/big-bro222.github.io/posts/zenject-1/AutoBind1.png\",\n    \"width\": \"60%\",\n    \"alt\": \"AutoBind1.png\"\n  }), \"\\n    \", mdx(\"br\", {\n    parentName: \"left\"\n  }), \"\\n    \", mdx(\"div\", {\n    parentName: \"left\",\n    \"style\": {\n      \"color\": \"#999\",\n      \"borderBottom\": \"1px solid #d9d9d9\",\n      \"display\": \"inline-block\"\n    }\n  }, \"\\n    Figure 3 Zenject binding script is attached directly to the gameobject\\n  \\t\")), mdx(\"h2\", null, \"Game Object Bind Methods\"), mdx(\"p\", null, \"For bindings that create new game objects (eg.\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FromComponentInNewPrefab\"), \",\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FromNewComponentOnNewGameObject\"), \", etc.) there are also two extra bind methods.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"WithGameObjectName\"), \"\\xA0= The name to give the new Game Object associated with this binding.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"UnderTransformGroup(string)\"), \"\\xA0= The name of the transform group to place the new game object under. This is especially useful for factories, which can be used to create many copies of a prefab, so it can be nice to have them automatically grouped together within the scene hierarchy.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"UnderTransform(Transform)\"), \"\\xA0= The actual transform to place the new game object under.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"UnderTransform(Method)\"), \"\\xA0= A method to provide the transform to use.\")), mdx(\"h2\", null, \"Conditional Binding\"), mdx(\"p\", null, \"In many cases you will want to restrict where a given dependency is injected. You can do this using the following syntax:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind<IFoo>().To<Foo1>().AsSingle().WhenInjectedInto<Bar1>();\\n\")), mdx(\"p\", null, \"Note that\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WhenInjectedInto\"), \"\\xA0is a simple shorthand for the following, which uses the more general\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"When()\"), \"\\xA0method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Container.Bind<IFoo>().To<Foo>().AsSingle().When(context => **context.ObjectType** == typeof(Bar));\\n\")), mdx(\"p\", null, \"The InjectContext class (which is passed as the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \"parameter above) contains a variety of information that you can use in your conditional, you can check \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject#conditional-bindings\"\n  }, \"here\"), \" for further queries.\"), mdx(\"h1\", null, \"4. Zenject Installer\"), mdx(\"p\", null, \"Often, there is some collections of related bindings for each sub-system and so it makes sense to group those bindings into a re-usable object. In Zenject this \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"re-usable\"), \" object is called an 'installer'. You can define a new installer as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class FooInstaller : MonoInstaller\\n{\\n    public override void InstallBindings()\\n    {\\n        Container.Bind<Bar>().AsSingle();\\n        Container.BindInterfacesTo<Foo>().AsSingle();\\n        // etc...\\n    }\\n}\\n\")), mdx(\"p\", null, \"You add bindings by overriding the InstallBindings method, which is called by whatever\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Context\"), \"\\n\\xA0the installer has been added to (usually this is\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SceneContext\"), \"). Installers are installed in the order given to\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SceneContext\"), \"(with scriptable object installers first, then mono installers, then prefab installers)\"), mdx(\"p\", null, \"Because the installer is simply a collection, you can also call installer in another installer, For example (which makes the management easier):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class BarInstaller : Installer<BarInstaller>\\n{\\n    public override void InstallBindings()\\n    {\\n        ...\\n    }\\n}\\n\\npublic class FooInstaller : MonoInstaller\\n{\\n    public override void InstallBindings()\\n    {\\n        BarInstaller.Install(Container);\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Usage of inspector in Zenject\"), mdx(\"h2\", null, \"Using Serializable\"), mdx(\"p\", null, \"One implication of writing most of your code as normal C# classes instead of MonoBehaviour's is that you lose the ability to configure data on them using the Unity inspector. You can however still take advantage of this in Zenject by using the following pattern:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"using System;\\nusing UnityEngine;\\nusing Zenject;\\n\\nnamespace zenject.nonmonobehaviour\\n{\\n    public class ZenjectNonMonobehaviour : MonoInstaller<ZenjectNonMonobehaviour>\\n    {\\n        public ZenjectInspector.Settings Settings;\\n\\n        public override void InstallBindings()\\n        {\\n            //The first way to expose the settings in the inspector\\n            //Container.BindInstance(Settings);\\n            //Container.BindInterfacesTo<ZenjectInspector>().AsSingle().NonLazy();\\n\\n            //The second way to expose the settings in the inspector\\n            Container.BindInterfacesTo<ZenjectInspector>().AsSingle().WithArguments(Settings);\\n        }\\n    }\\n\\n    public class ZenjectInspector : ITickable\\n    {\\n        private Settings mSettings;\\n\\n        public ZenjectInspector(Settings settings)\\n        {\\n            this.mSettings = settings;\\n        }\\n\\n        public void Tick()\\n        {\\n            Debug.Log(\\\"Speed:\\\" + mSettings.Speed);\\n        }\\n\\n        [Serializable]\\n        public class Settings\\n        {\\n            public float Speed;\\n        }\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Using Scriptable Object Installer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Open Unity\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Right click somewhere in the Project tab and select\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Create -> Zenject -> ScriptableObjectInstaller\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Name it GameSettingsInstaller\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Right click again in the same location\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Select the newly added menu item\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Create -> Installers -> GameSettingsInstaller\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class GameSettings : ScriptableObjectInstaller\\n{\\n    public Player.Settings Player;\\n    public SomethingElse.Settings SomethingElse;\\n    // ... etc.\\n\\n    public override void InstallBindings()\\n    {\\n        Container.BindInstances(Player, SomethingElse, etc.);\\n    }\\n}\\n\\npublic class Player : ITickable\\n{\\n    readonly Settings _settings;\\n    Vector3 _position;\\n\\n    public Player(Settings settings)\\n    {\\n        _settings = settings;\\n    }\\n\\n    public void Tick()\\n    {\\n        _position += Vector3.forward * _settings.Speed;\\n    }\\n\\n    [Serializable]\\n    public class Settings\\n    {\\n        public float Speed;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Bind , Installer and inject are the most important concepts in Zenject. In the next post, I will talk about Non-mono Classes, Signal bus for event handling, and Factory.\"), mdx(\"h1\", null, \"Reference\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/modesttree/Zenject\"\n  }, \"https://github.com/modesttree/Zenject\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://erdiizgi.com/dependency-injection-unity-zenject/\"\n  }, \"https://erdiizgi.com/dependency-injection-unity-zenject/\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=6tn8pMQuxEk&list=PLKERDLXpXl_jNJPY2czQcfPXW4BJaGZc_&index=2\"\n  }, \"https://www.youtube.com/watch?v=6tn8pMQuxEk&list=PLKERDLXpXl\", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"jNJPY2czQcfPXW4BJaGZc\"), \"&index=2\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.csdn.net/unity3d_xyz/category_8487718.html\"\n  }, \"https://blog.csdn.net/unity3d_xyz/category_8487718.html\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"DI in Zenject (Basic concepts and Hello world) 1. Zenject Hello world Zenject  is a lightweight highly performant DI(dependency injection…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/blog/zenject/1","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}