{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/blog/collection-csharp-basic/1",
    "result": {"data":{"post":{"slug":"/blog/collection-csharp-basic/1","title":"Collections in C# (The basics 1)","date":"03.05.2022","tags":[{"name":"C# basics","slug":"c-basics"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Collections in C# (The basics 1)\",\n  \"date\": \"2022-05-03T00:00:00.000Z\",\n  \"slug\": \"/blog/collection-csharp-basic/1\",\n  \"tags\": [\"C# basics\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"1. What is collections\"), mdx(\"p\", null, \"There are usually three default namespaces when creating a new C# script in Unity, they are\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\")), mdx(\"p\", null, \"Of Course, you can change the default scripts using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.notion.so/Changing-Default-Scripts-in-Unity-6952f533e80a4ab780546c472dc9af4c\"\n  }, \"this method\"), \". But still, it\\u2019s easy to see that collection is a very important concept in programming, especially C#.\"), mdx(\"p\", null, \"According to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections\"\n  }, \"Microsoft coding guide\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Collections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"grow and shrink dynamically\"), \" as the needs of the application change.\")), mdx(\"p\", null, \"The System.Collection namespace contains interfaces and classes that define various collections of objects, such as lists, queues, bit arrays, hash tables, and dictionaries.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Collection.Generic\"), \" namespace contains interfaces and classes that define generic collections, which allow users to create strongly typed collections that provide \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"better type safety and performance\"), \" than non-generic strongly typed collections.\"), mdx(\"h1\", null, \"2. System.Collection.Generic\"), mdx(\"p\", null, \"If your collection contains elements of only \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"one data type\"), \", you can use one of the classes in the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic\"\n  }, \"System.Collections.Generic\"), \" namespace. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A generic collection enforces type safety so that no other data type can be added to it. When you retrieve an element from a generic collection, you do not have to determine its data type or convert it.\")), mdx(\"p\", null, \"There are 9 basic classes:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Dictionary<TKey,TValue\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"SortedDictionary<TKey,TValue\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"SortedList<TKey,TValue\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List<T\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"LinkedList<T\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"HashSet<T\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"SortedSet<T\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Stack<T\", \">\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Queue<T\", \">\")), mdx(\"h2\", null, \"2.1 Collections with<key, value> pair\"), mdx(\"h3\", null, \"2.1.1 \", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0\"\n  }, \"Dictionary<TKey,TValue>\")), mdx(\"p\", null, \"Dictionary is a very common data structure to access each element, it is a generic collection that stores key-value pairs in no particular order. It always takes the same time no matter how many elements is stored with an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cnblogs.com/incerry/p/10325290.html\"\n  }, \"internal mechanism\"), \" of Hashtable.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pros:\"), \" take the same time to query, add, remove an element no matter how many elements are stored\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cons:\"), \" dictionary has no particular order, so it will take time to iterate through the dictionary\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"// Create a new dictionary of strings, with string keys.\\nDictionary<string, string> openWith =\\n    new Dictionary<string, string>();\\n// Add some elements to the dictionary. There are no\\n// duplicate keys, but some of the values are duplicates.\\nopenWith.Add(\\\"txt\\\", \\\"notepad.exe\\\");\\n// The indexer can be used to change the value associated\\n// with a key.If a key does not exist, setting the indexer for that key\\n// adds a new key/value pair.\\nopenWith[\\\"rtf\\\"] = \\\"winword.exe\\\";\\nConsole.WriteLine(\\\"For key = \\\\\\\"rtf\\\\\\\", value = {0}.\\\",\\n    openWith[\\\"rtf\\\"]);\\n\\n// The indexer throws an exception if the requested key is\\n// not in the dictionary.\\ncatch (KeyNotFoundException)\\n{\\n    Console.WriteLine(\\\"Key = \\\\\\\"tif\\\\\\\" is not found.\\\");\\n}\\n// When a program often has to try keys that turn out not to\\n// be in the dictionary, TryGetValue can be a more efficient\\n// way to retrieve values.\\nstring value = \\\"\\\";\\nopenWith.TryGetValue(\\\"tif\\\", out value)\\n\\n// ContainsKey can be used to test keys before inserting\\n// them.\\nopenWith.ContainsKey(\\\"ht\\\"))\\n// When you use foreach to enumerate dictionary elements,\\n// the elements are retrieved as KeyValuePair objects.\\nforeach( KeyValuePair<string, string> kvp in openWith )\\n{\\n    Console.WriteLine(\\\"Key = {0}, Value = {1}\\\",\\n        kvp.Key, kvp.Value);\\n}\\n\\n// To get the values alone, use the Values property.\\nDictionary<string, string>.ValueCollection valueColl =\\n// To get the keys alone, use the Keys property.\\nDictionary<string, string>.KeyCollection keyColl =\\n    openWith.Keys;\\n\\n// Use the Remove method to remove a key/value pair.\\nopenWith.Remove(\\\"doc\\\");\\n\")), mdx(\"h3\", null, \"2.1.2 SortedDictionary<TKey,TValue>\"), mdx(\"p\", null, \"The usage of SortedDictionary is quite similar to Dictionary although it\\u2019s implemented using\\nbinary-tree.It has O(log n) retrieval.While using foreach loop, the output will be ordered\\nby key values in ascending order\\uFF08on the other hand, dictionary will be ordered by the time\\nthe keyvalue pair is added\\uFF09\"), mdx(\"p\", null, \"note that TKey must implement \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IComparable<TKey\", \">\"), \" interface in order to be sorted.\\uFF08I haven\\u2019t find any useful scenario for using SortedDictionary yet, except for that the unique performance while doing foreach loop\\uFF09\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"SortedDictionary<int, string> sd = new SortedDictionary<int, string>();\\n        sd.Add(9, \\\"\\u4E5D\\\");\\n        sd.Add(8, \\\"\\u516B\\\");\\n        sd.Add(7, \\\"\\u4E03\\\");\\n        sd.Add(6, \\\"\\u516D\\\");\\n        sd.Add(1, \\\"\\u4E00\\\");\\n        sd.Add(5, \\\"\\u4E94\\\");\\n        sd.Add(3, \\\"\\u4E09\\\");\\n        sd.Add(2, \\\"\\u4E8C\\\");\\n        Debug.Log(\\\"-----SortDictionary-----\\\");\\n        //print the dictionary\\n        foreach (var item in sd)\\n        {\\n            string info = string.Format(\\\" Key = {0}, Value = {1}\\\", item.Key, item.Value);\\n            Debug.Log(info);\\n        }\\n\\n//foreach loop with print from key 1 to key 9\\n\")), mdx(\"h3\", null, \"2.1.3 SortedList<Tkey,TValue>\"), mdx(\"p\", null, \"The\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2?view=net-6.0\"\n  }, \"SortedList<TKey,TValue>\"), \"\\xA0generic class is an array of key/value pairs with O(log\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \") retrieval, where n is the number of elements in the dictionary. In this, it is similar to the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2?view=net-6.0\"\n  }, \"SortedDictionary<TKey,TValue>\"), \"\\xA0generic class. The two classes have similar object models, and both have O(log\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \") retrieval. Where the two classes differ is in memory use and speed of insertion and removal:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"SortedList<TKey,TValue>\\xA0uses less memory\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"SortedDictionary<TKey,TValue>\\xA0has faster insertion and removal operations\"), \" for unsorted data, O(log\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \") as opposed to O(\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \") for\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2?view=net-6.0\"\n  }, \"SortedList<TKey,TValue>\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the list is populated all at once from sorted data,\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2?view=net-6.0\"\n  }, \"SortedList<TKey,TValue>\"), \"\\xA0is faster than\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2?view=net-6.0\"\n  }, \"SortedDictionary<TKey,TValue>\"), \".\")), mdx(\"p\", null, \"Another difference is that\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2?view=net-6.0\"\n  }, \"SortedList<TKey,TValue>\"), \"\\xA0supports get values and keys \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"by index\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"\\n        // Create a new sorted list of strings, with string\\n        // keys.\\n        SortedList<string, string> openWith =\\n            new SortedList<string, string>();\\n\\n        // Add some elements to the list. There are no\\n        // duplicate keys, but some of the values are duplicates.\\n        openWith.Add(\\\"txt\\\", \\\"notepad.exe\\\");\\n        openWith.Add(\\\"bmp\\\", \\\"paint.exe\\\");\\n\\n        // ContainsKey can be used to test keys before inserting\\n        // them.\\n        openWith.ContainsKey(\\\"ht\\\")\\n\\n        // To get the values alone, use the Values property.\\n        IList<string> ilistValues = openWith.Values;\\n        // To get the keys alone, use the Keys property.\\n        IList<string> ilistKeys = openWith.Keys;\\n\\n        // Use the Remove method to remove a key/value pair.\\n        Console.WriteLine(\\\"\\\\nRemove(\\\\\\\"doc\\\\\\\")\\\");\\n        openWith.Remove(\\\"doc\\\");\\n\\n        //get the index of a key\\n        Debug.Log(\\\"Key 7 is has the index of\\\"+sd.IndexOfKey(7));\\n        //remove the item with biggest key\\n        openWith.RemoveAt(sd.Count - 1);\\n\\n        //get value by index\\n        string value=(openWith.Values)[3];\\n        Debug.Log(\\\"the forth value is \\\" + value);\\n\\n\")), mdx(\"h3\", null, \"2.2.1 \", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\")), mdx(\"p\", null, \"Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists.\"), mdx(\"p\", null, \"The\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \"\\xA0class is the generic equivalent of the\\xA0ArrayList\\xA0class. It implements the\\xA0IList<T\", \">\", \"\\xA0generic interface by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using an array whose size is dynamically increased as required\"), \". The capacity of the\\xA0List<T\", \">\", \" is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added. (This can be very heavy and waste a lot of rooms when the items number is huge)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"//The default length is 4 and is increased exponentially\\nint num = (_items.Length == 0) ? 4 : (_items.Length * 2)\\n\")), mdx(\"p\", null, \"The\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.trimexcess?view=net-6.0\"\n  }, \"TrimExcess\"), \"\\xA0method is used to reduce the capacity to match the count, and the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.capacity?view=net-6.0\"\n  }, \"Capacity\"), \" and\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.count?view=net-6.0\"\n  }, \"Count\"), \" properties are displayed. If the unused capacity had been less than 10 percent of total capacity, the list would not have been resized.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"\\n        // Create a list of parts.\\n        List<Part> parts = new List<Part>();\\n\\n        // Add parts to the list.\\n        parts.Add(new Part() { PartName = \\\"crank arm\\\", PartId = 1234 });\\n        parts.Add(new Part() { PartName = \\\"chain ring\\\", PartId = 1334 });\\n\\n        // Check the list for part #1734. This calls the IEquatable.Equals method\\n        // of the Part class\\n        parts.Contains(new Part { PartId = 1734, PartName = \\\"\\\" }));\\n\\n        // Insert a new item at position 2.\\n        parts.Insert(2, new Part() { PartName = \\\"brake lever\\\", PartId = 1834 });\\n\\n        // This will remove part 1534 even though the PartName is different,\\n        // because the Equals method only checks PartId for equality.\\n        parts.Remove(new Part() { PartId = 1534, PartName = \\\"cogs\\\" });\\n\\n        // This will remove the part at index 3.\\n        parts.RemoveAt(3);\\n\\n        string[] input = { \\\"Brachiosaurus\\\",\\n                           \\\"Amargasaurus\\\",\\n                           \\\"Mamenchisaurus\\\" };\\n\\n        List<string> dinosaurs = new List<string>(input);\\n        dinosaurs.AddRange(dinosaurs);\\n\\n        dinosaurs.RemoveRange(2, 2);\\n\\n        dinosaurs.InsertRange(3, input);\\n\\n        string[] output = dinosaurs.GetRange(2, 3).ToArray();\\n\")), mdx(\"p\", null, \"The\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \"\\xA0class uses both an equality comparer and an ordering comparer.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.contains?view=net-6.0\"\n  }, \"Contains\"), \",\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.indexof?view=net-6.0\"\n  }, \"IndexOf\"), \",\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.lastindexof?view=net-6.0\"\n  }, \"LastIndexOf\"), \", and\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.remove?view=net-6.0\"\n  }, \"Remove\"), \"\\xA0use an equality comparer for the list elements. If type\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"T\"), \"\\xA0implements the\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1?view=net-6.0\"\n  }, \"IEquatable<T\", \">\"), \"\\xA0generic interface, then the equality comparer is the\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1.equals?view=net-6.0#system-iequatable-1-equals(-0)\"\n  }, \"Equals(T)\"), \"\\xA0method of that interface; otherwise, the default equality comparer is\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.object.equals?view=net-6.0#system-object-equals(system-object)\"\n  }, \"Object.Equals(Object)\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.binarysearch?view=net-6.0\"\n  }, \"BinarySearch\"), \"\\xA0and\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.sort?view=net-6.0\"\n  }, \"Sort\"), \"\\xA0use an ordering comparer for the list elements. If type\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"T\"), \"\\xA0implements the\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=net-6.0\"\n  }, \"IComparable<T\", \">\"), \"\\xA0generic interface, then the default comparer is the\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-6.0#system-icomparable-1-compareto(-0)\"\n  }, \"CompareTo(T)\"), \"\\xA0method of that interface; otherwise, if type\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"T\"), \"\\xA0implements the nongeneric\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable?view=net-6.0\"\n  }, \"IComparable\"), \"\\xA0interface, then the default comparer is the\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable.compareto?view=net-6.0#system-icomparable-compareto(system-object)\"\n  }, \"CompareTo(Object)\"), \"\\xA0method of that interface. If type\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"T\"), \"\\xA0implements neither interface, then there is no default comparer, and a comparer or comparison delegate must be provided explicitly. The\\xA0\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \"\\xA0is not guaranteed to be sorted. \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"You must sort the\\xA0\", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \"\\xA0before performing operations (such as\\xA0\", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.binarysearch?view=net-6.0\"\n  }, \"BinarySearch\"), \") that require the\\xA0\", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \"\\xA0to be sorted.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0\"\n  }, \"List<T\", \">\"), \" accepts\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null\"), \"\\xA0as a valid value for reference types and allows duplicate elements.\")), mdx(\"h3\", null, \"2.2.2 LinkedList<T\", \">\"), mdx(\"p\", null, \"You can remove nodes and reinsert them, either in the same list or in another list, which results in no additional objects allocated on the heap.\"), mdx(\"p\", null, \"Each node in a\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0\"\n  }, \"LinkedList<T\", \">\"), \"\\xA0object is of the type\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlistnode-1?view=net-6.0\"\n  }, \"LinkedListNode<T\", \">\"), \". Because the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0\"\n  }, \"LinkedList<T\", \">\"), \"\\xA0is doubly linked, each node points forward to the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlistnode-1.next?view=net-6.0\"\n  }, \"Next\"), \"\\xA0node and backward to the\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlistnode-1.previous?view=net-6.0\"\n  }, \"Previous\"), \"\\xA0node.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0\"\n  }, \"LinkedList<T\", \">\"), \"\\xA0accepts\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \"\\xA0as a valid\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlistnode-1.value?view=net-6.0\"\n  }, \"Value\"), \"\\xA0property for reference types and allows duplicate values.\"), mdx(\"p\", null, \"The\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0\"\n  }, \"LinkedList<T\", \">\"), \"\\xA0class does not support chaining, splitting, cycles, or other features that can leave the list in an inconsistent state. The list remains consistent on a single thread. The only multithreaded scenario supported by\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0\"\n  }, \"LinkedList<T\", \">\"), \"\\xA0is multithreaded read operations.\"), mdx(\"p\", null, \"LinkedList is mostly used for a more precise operation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"\\n        // Create the link list.\\n        string[] words =\\n            { \\\"the\\\", \\\"fox\\\", \\\"jumps\\\", \\\"over\\\", \\\"the\\\", \\\"dog\\\" };\\n        LinkedList<string> sentence = new LinkedList<string>(words);\\n        Console.WriteLine(sentence.Contains(\\\"jumps\\\"));\\n\\n        // Add the word 'today' to the beginning of the linked list.\\n        sentence.AddFirst(\\\"today\\\");\\n\\n        // Move the first node to be the last node.\\n        LinkedListNode<string> mark1 = sentence.First;\\n        sentence.RemoveFirst();\\n        sentence.AddLast(mark1);\\n       \\n        // Move the last node to be the first node.\\n        mark1 = sentence.Last;\\n        sentence.RemoveLast();\\n        sentence.AddFirst(mark1);\\n       \\n\\n        // Indicate the last occurence of 'the'.\\n        sentence.RemoveFirst();\\n        LinkedListNode<string> current = sentence.FindLast(\\\"the\\\");\\n\\n        // Indicate 'fox' node.\\n        current = sentence.Find(\\\"fox\\\");\\n \\n\\n        // Add 'quick' and 'brown' before 'fox':\\n        sentence.AddBefore(current, \\\"quick\\\");\\n        \\n        // Keep a reference to the current node, 'fox',\\n        // and to the previous node in the list. Indicate the 'dog' node.\\n        mark1 = current;\\n        LinkedListNode<string> mark2 = current.Previous;\\n        current = sentence.Find(\\\"dog\\\");\\n\\n\")), mdx(\"h3\", null, \"2.2.3 Stack<T\", \">\", \" and Queue<T\", \">\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Stack\"), \"Represents a variable size last-in-first-out (LIFO) collection of instances of the same specified type. Stack<T\", \">\", \"\\xA0is implemented as an array.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Queue\"), \" implements a generic queue as a circular array. Objects stored in a\\xA0Queue<T\", \">\", \"\\xA0are inserted at one end and removed from the other. \\uFF08first-in-first-out\\uFF09\"), mdx(\"p\", null, \"Stacks and queues are useful when you might want to discard an element after retrieving its value. Use\\xA0Queue<T\", \">\", \"\\xA0if you need to access the information in the same order that it is stored in the collection. Use\\xA0System.Collections.Generic.Stack<T\", \">\", \"\\xA0if you need to access the information in reverse order.\"), mdx(\"p\", null, \"A common use for\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1?view=net-6.0\"\n  }, \"System.Collections.Generic.Stack<T\", \">\"), \"\\xA0is to preserve variable states during calls to other procedures.\"), mdx(\"p\", null, \"-Three main operations can be performed on a\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1?view=net-6.0\"\n  }, \"System.Collections.Generic.Stack<T\", \">\"), \"\\xA0and its elements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Push\\xA0inserts an element at the top of the\\xA0Stack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pop\\xA0removes an element from the top of the\\xA0Stack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Peek\\xA0returns an element that is at the top of the\\xA0Stack\\xA0but does not remove it from the\\xA0Stack.\")), mdx(\"p\", null, \"As elements are added to a\\xA0Stack<T\", \">\", \", the capacity is automatically increased as required by reallocating the internal array. \"), mdx(\"p\", null, \"If\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.count?view=net-6.0\"\n  }, \"Count\"), \"\\xA0is less than the capacity of the stack,\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.push?view=net-6.0\"\n  }, \"Push\"), \"\\xA0is an O(1) operation. If the capacity needs to be increased to accommodate the new element,\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.push?view=net-6.0\"\n  }, \"Push\"), \"\\xA0becomes an O(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \") operation, where\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \"\\xA0is\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.count?view=net-6.0\"\n  }, \"Count\"), \".\\xA0\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.pop?view=net-6.0\"\n  }, \"Pop\"), \"\\xA0is an O(1) operation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Stack<string> stack = new Stack<string>();\\nstack.Push(\\\"object\\\");//add data\\nstack.Peek();//get data without delete\\nstack.Pop();//get data and delete from the stack\\n\")), mdx(\"p\", null, \"-Three main operations can be performed on a\\xA0Queue<T\", \">\", \"\\xA0and its elements:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Enqueue\\xA0adds an element to the end of the\\xA0Queue<T\", \">\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dequeue\\xA0removes the oldest element from the start of the\\xA0Queue<T\", \">\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Peek\\xA0peek returns the oldest element that is at the start of the\\xA0Queue<T\", \">\", \"\\xA0but does not remove it from the\\xA0Queue<T\", \">\", \".\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"//Queue is useful for performing tasks\\nQueue<string> queue = new Queue<string>();\\nqueue.Enqueue(\\\"object\\\");//add data\\nqueue.Enqueue(\\\"object1\\\");\\nforeach (var item in queue)\\n{\\n Console.WriteLine(item);\\n}\\nqueue.Dequeue();//get the earliest item and delete from the queue\\nqueue.Peek();//get data without delete\\n\")), mdx(\"h3\", null, \"2.2.4 SortedSet<T\", \">\"), mdx(\"h3\", null, \"2.2.5 HashSet<T\", \">\"), mdx(\"h3\", null, \"2.2.6 PriorityQueue<TElement,TPriority\", \">\"), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h1\", null, \"Reference\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections\"\n  }, \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections?view=net-6.0\"\n  }, \"System.Collection\"), \" documentation page\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0\"\n  }, \"System.Collection.Generic\"), \" documentation page\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cnblogs.com/incerry/p/10325290.html\"\n  }, \"The implementation of Dictionary (ZH)\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"1. What is collections There are usually three default namespaces when creating a new C# script in Unity, they are Of Course, you can change…","timeToRead":5,"banner":null}},"pageContext":{"slug":"/blog/collection-csharp-basic/1","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}